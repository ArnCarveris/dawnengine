Actor* createActor()
// Sugar for createActor().addComponent<Transform>(p, q, s).
Actor* createActor(const Position& p, const Quaternion& q = Quat::identity, const Vec3& scale = Vec3::one);

addComponent<Transform> specialisation sets `Transform* transform` directly.
// Transform is a node in the scene graph:
// Parenting: getTransform().addChild(actor)
// Sugar for:
// getComponent<Transform>().addChild(actor->getComponent<Transform>())

----------------

Actor stores a direct reference to Transform component.

----------------

components implemment:

class Component2 {
public:
    DW_OBJECT(Component2);

    Component2(Context* context);

    virtual void update(float dt);

    ComponentId id() const; // Sugar for class().typeHash();

private:

}

i.e.

class Transform : public Component2 {
public:
    DW_OBJECT(Transform);

    Transform(...);

    void update(float dt) override;

    // Scene graph.
    void addChild(ActorId id) { addChild(world().actorById(id)); }
    void addChild(Actor* actor) { addChild(actor->transform()); }
    void addChild(Transform* child_transform);

private:
    Mat4 cached_transform_matrix_;
    Transform* parent_;
    Vector<Transform*> children_;
}

----------------

Actor* actor = createActor(Transform::default);
actor->addComponent<RenderableComponent>(renderable);

Actor* wing = createActor(Position{8.0f, 0.0f, 0.0f}, Quat::identity)
    .addComponent<Renderable>(wing_renderable);
actor->addChild(wing);

Actor* wing2 = createActor(Position{-8.0f, 0.0f, 0.0f}, Quat::identity, Vec3{-1.0f, 1.0f, 1.0f)})
    .addComponent<Renderable>(wing_renderable);
actor->addChild(wing2);